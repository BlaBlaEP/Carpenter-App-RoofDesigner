#include "assimptest.h"
#include <assimp/Importer.hpp>      // C++ importer interface
#include <assimp/scene.h>           // Output data structure
#include <assimp/postprocess.h>
#include <assimp/material.h>
#include <assimp/Exporter.hpp>
#include <glm/glm.hpp>
#include <glm/gtx/rotate_vector.hpp>
#include <glm/gtx/vector_angle.hpp>
#include <QDebug>

assimpTest::assimpTest()
{
    //Assimp::Importer Importer;

    //const aiScene* scene = Importer.ReadFile("empty.dae", aiProcess_Triangulate | aiProcess_GenSmoothNormals | aiProcess_FlipUVs);

    aiScene* scene = new aiScene();

    scene->mRootNode = new aiNode();

    scene->mMaterials = new aiMaterial*[ 1 ];
    scene->mMaterials[ 0 ] = nullptr;
    scene->mNumMaterials = 1;

    scene->mMaterials[ 0 ] = new aiMaterial();

    scene->mMeshes = new aiMesh*[ 1 ];
    scene->mMeshes[ 0 ] = nullptr;
    scene->mNumMeshes = 2;

    scene->mMeshes[ 0 ] = new aiMesh();
    scene->mMeshes[ 0 ]->mMaterialIndex = 0;

    scene->mMeshes[ 1 ] = new aiMesh();
    scene->mMeshes[ 1 ]->mMaterialIndex = 0;

    scene->mRootNode->mMeshes = new unsigned int[ 2 ];
    scene->mRootNode->mMeshes[ 0 ] = 0;
    scene->mRootNode->mMeshes[ 1 ] = 1;

    scene->mRootNode->mNumMeshes = 2;

    auto pMeshRectangle = scene->mMeshes[ 0 ];
    auto pMeshCylinder = scene->mMeshes[ 1 ];


    std::vector<glm::vec3> verticesRectangle;
    std::vector<glm::vec3> verticesCylinder;


    glm::vec3 pointer = glm::vec3(2.f, 7.f, 0.f);

    float angle = glm::angle(glm::normalize(pointer), glm::vec3(1,0,0)) - 90.f;
    float radius = 1.0f;
    float length = glm::length(pointer);


    glm::vec3 a = glm::vec3(radius, 0, radius);
    glm::vec3 b = glm::vec3(-radius, 0, radius);
    glm::vec3 c = glm::vec3(radius, 0, -radius);
    glm::vec3 d = glm::vec3(-radius, 0, -radius);

    glm::vec3 e = glm::vec3(radius, length, radius);
    glm::vec3 f = glm::vec3(-radius, length, radius);
    glm::vec3 g = glm::vec3(radius, length, -radius);
    glm::vec3 h = glm::vec3(-radius, length, -radius);

    glm::vec3 allVertices[8] =  { a,b,c,d,e,f,g,h };

    for(int i = 0; i < 8; i++)
    {
        verticesRectangle.push_back(glm::rotateZ(allVertices[i], angle));
    }


    // CYLINDER BEGIN ------------------------------------------------------
    int numberOfSides = 40;
    angle = 360.f / numberOfSides;
    radius = 0.5f;

    int numberOfVertices = numberOfSides * 2 + 2;
    int numberOfFaces = numberOfSides * 4;

    std::vector<glm::vec3> cylinderVertices;

    for(int i = 0; i < numberOfVertices; i++) {
        float height = i >= numberOfSides ^ i == numberOfSides * 2 ? length : 0.f;
        if(i >= numberOfSides * 2) {
            cylinderVertices.push_back(glm::vec3(0.f, 0.f, height));
        }
        else {
            cylinderVertices.push_back(glm::vec3(glm::cos(glm::radians(angle * (i % numberOfSides))) * radius, glm::sin(glm::radians(angle * (i % numberOfSides))) * radius, height));
        }
    }

    for(int i = 0; i < numberOfVertices; i++) {
        verticesCylinder.push_back(cylinderVertices[i]);
        qDebug() << "inserting (" << cylinderVertices[i].x << ", " << cylinderVertices[i].y << "," << cylinderVertices[i].z << ")";
    }
    // CYLINDER END --------------------------------------------------------

    const auto& vRectangleVertices = verticesRectangle;
    const auto& vCylinderVertices = verticesCylinder;


    pMeshRectangle->mVertices = new aiVector3D[ vRectangleVertices.size() ];
    pMeshRectangle->mNormals = new aiVector3D[ 0 ];
    pMeshRectangle->mNumVertices = vRectangleVertices.size();

    int j = 0;
    for ( auto itr = vRectangleVertices.begin(); itr != vRectangleVertices.end(); ++itr )
    {
        pMeshRectangle->mVertices[ itr - vRectangleVertices.begin() ] = aiVector3D( vRectangleVertices[j].x, vRectangleVertices[j].y, vRectangleVertices[j].z );
        j++;
    }

    pMeshRectangle->mFaces = new aiFace[ /*12 +*/ numberOfFaces ];
    pMeshRectangle->mNumFaces = (unsigned int)(/*12 +*/ numberOfFaces);

    // Cylinder

    pMeshCylinder->mVertices = new aiVector3D[ vCylinderVertices.size() ];
    pMeshCylinder->mNormals = new aiVector3D[ 0 ];
    pMeshCylinder->mNumVertices = vCylinderVertices.size();

    j = 0;
    for ( auto itr = vCylinderVertices.begin(); itr != vCylinderVertices.end(); ++itr )
    {
        pMeshCylinder->mVertices[ itr - vCylinderVertices.begin() ] = aiVector3D( vCylinderVertices[j].x, vCylinderVertices[j].y, vCylinderVertices[j].z );
        j++;
    }

    pMeshCylinder->mFaces = new aiFace[ /*12 +*/ numberOfFaces ];
    pMeshCylinder->mNumFaces = (unsigned int)(/*12 +*/ numberOfFaces);

    int facesIndex[36] = {
        0,1,2,
        1,2,3,
        0,1,4,
        1,4,5,
        0,2,4,
        2,4,6,
        2,3,7,
        2,6,7,
        1,3,5,
        3,5,7,
        4,5,6,
        5,6,7
    };

    int k = 0;
    for(int i = 0; i < 12; i++)
    {
        aiFace &face = pMeshRectangle->mFaces[i];
        face.mIndices = new unsigned int[3];
        face.mNumIndices = 3;

        face.mIndices[0] = facesIndex[k];
        face.mIndices[1] = facesIndex[k+1];
        face.mIndices[2] = facesIndex[k+2];
        k = k + 3;
    }

    int bottomCenter = numberOfSides * 2;
    int topCenter = bottomCenter + 1;
    int offset = 12;
    offset = 0;

    for(int i = 0, k = 0; i < numberOfSides * 2; i++) {
        int j = i + offset; // offset from before

        // top and bottom
        if(i < numberOfSides) {
            aiFace &faceBottom = pMeshCylinder->mFaces[i*2+offset];

            faceBottom.mIndices = new unsigned int[3];
            faceBottom.mNumIndices = 3;

            faceBottom.mIndices[0] = k + offset;
            faceBottom.mIndices[1] = (k + 1) % numberOfSides + offset;
            faceBottom.mIndices[2] = bottomCenter + offset;

            qDebug() << i*2+offset << ": (" << faceBottom.mIndices[0] << ", " << faceBottom.mIndices[1] << ", " << faceBottom.mIndices[2] << ")";

            if((i*2+1) < numberOfFaces) {
                aiFace &faceTop = pMeshCylinder->mFaces[i*2+1+offset];
                faceTop.mIndices = new unsigned int[3];

                faceTop.mNumIndices = 3;

                faceTop.mIndices[0] = k + numberOfSides + offset;
                faceTop.mIndices[1] = (k + 1) % numberOfSides + numberOfSides + offset;
                faceTop.mIndices[2] = topCenter + offset;

                qDebug() << i*2+1+offset << ": (" << faceTop.mIndices[0] << ", " << faceTop.mIndices[1] << ", " << faceTop.mIndices[2] << ")";
            }
        }
        // side
        else {
            if(i == numberOfSides) {
                k = 0;
            }


            aiFace &sideFace1 = pMeshCylinder->mFaces[i*2+offset];

            sideFace1.mIndices = new unsigned int[3];
            sideFace1.mNumIndices = 3;

            sideFace1.mIndices[0] = k  + offset;
            sideFace1.mIndices[1] = (k + numberOfSides)  + offset;
            sideFace1.mIndices[2] = (k + 1) % numberOfSides + numberOfSides + offset;

            qDebug() << i*2+offset << ": (" << sideFace1.mIndices[0] << ", " << sideFace1.mIndices[1] << ", " << sideFace1.mIndices[2] << ")";

            if((i*2+1) < numberOfFaces) {
                aiFace &sideFace2 = pMeshCylinder->mFaces[i*2+1+offset];

                sideFace2.mIndices = new unsigned int[3];
                sideFace2.mNumIndices = 3;


                sideFace2.mIndices[0] = k + offset;
                sideFace2.mIndices[1] = (k + 1) % numberOfSides + offset;
                sideFace2.mIndices[2] = (k + 1) % numberOfSides + numberOfSides + offset;

                qDebug() << i*2+1+offset << ": (" << sideFace2.mIndices[0] << ", " << sideFace2.mIndices[1] << ", " << sideFace2.mIndices[2] << ")";
            }


        }

        k++;
    }

    Assimp::Exporter *exporter = new Assimp::Exporter();

    /*bool end = false;
    for(size_t i = 0; i < exporter->GetExportFormatCount() && !end; i++) {
        const aiExportFormatDesc* format = exporter->GetExportFormatDescription(0);
        end = false;
    }*/


    exporter->Export(scene, "collada", "/home/osboxes/honk.dae");
}

